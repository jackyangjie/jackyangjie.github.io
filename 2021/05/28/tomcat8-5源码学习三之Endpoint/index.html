<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Healthy Mind">
    
    <title>
        
            tomcat8.5源码学习三之Endpoit |
        
        Healthy Mind
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.png">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"examle.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/logo.png","favicon":"/images/logo.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Healthy Mind
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">tomcat8.5源码学习三之Endpoit</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/logo.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Healthy Mind</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-05-28 14:08:15
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/tomcat/">tomcat</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/tomcat/Endpoint/">Endpoint</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/tomcat/">tomcat</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Endpoint/">Endpoint</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>本篇主要学习tomcat 是如何把Connector线程池里的请求数据转发到servlet的</p>
<p>上一篇 我们已经可能到了 <strong>org.apache.tomcat.util.net.NioEndpoint</strong> 的 ***bind()***方法</p>
<p>bind方法其实就是nio端口绑定的方法</p>
<p>真正启动线程池的方法是 <strong>startInternal()</strong> 方法，源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start the NIO endpoint, creating acceptor, poller threads.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">           running = <span class="keyword">true</span>;</span><br><span class="line">           paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">           processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                   socketProperties.getProcessorCache());</span><br><span class="line">           eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                           socketProperties.getEventCache());</span><br><span class="line">           nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                   socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Create worker collection</span></span><br><span class="line">           <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">               createExecutor();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Start poller threads</span></span><br><span class="line">           pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">               pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">               Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">               pollerThread.setPriority(threadPriority);</span><br><span class="line">               pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">               pollerThread.start();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           startAcceptorThreads();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>  这里主要查看 Poller的类的run 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The background thread that adds sockets to the Poller, checks the</span></span><br><span class="line"><span class="comment">       * poller for triggered events and hands the associated socket off to an</span></span><br><span class="line"><span class="comment">       * appropriate processor as events occur.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                      hasEvents = events();</span><br><span class="line">                      <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                          <span class="comment">//do a non blocking select</span></span><br><span class="line">                          keyCount = selector.selectNow();</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          keyCount = selector.select(selectorTimeout);</span><br><span class="line">                      &#125;</span><br><span class="line">                      wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                      events();</span><br><span class="line">                      timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          selector.close();</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                          log.error(sm.getString(<span class="string">&quot;endpoint.nio.selectorCloseFail&quot;</span>), ioe);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                  ExceptionUtils.handleThrowable(x);</span><br><span class="line">                  log.error(<span class="string">&quot;&quot;</span>,x);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">              <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">              Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                  keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">              <span class="comment">// any active event.</span></span><br><span class="line">              <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                  SelectionKey sk = iterator.next();</span><br><span class="line">                  NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">                  <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">                  <span class="comment">// cancelledKey()</span></span><br><span class="line">                  <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      iterator.remove();</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      iterator.remove();</span><br><span class="line">                      processKey(sk, attachment);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">//process timeouts</span></span><br><span class="line">              timeout(keyCount,hasEvents);</span><br><span class="line">          &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">          getStopLatch().countDown();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码大部分就是状态修改，唯一可以看到的 就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processKey(sk, attachment);</span><br></pre></td></tr></table></figure>

<p>接下来就看 这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">                   cancelledKey(sk);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                       <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                           <span class="comment">//处理文件上传</span></span><br><span class="line">                           processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                           <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="comment">// Read goes before write</span></span><br><span class="line">                           <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                               <span class="comment">//数据读取</span></span><br><span class="line">                               <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                   closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                   closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                               cancelledKey(sk);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//invalid key</span></span><br><span class="line">                   cancelledKey(sk);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">               cancelledKey(sk);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               ExceptionUtils.handleThrowable(t);</span><br><span class="line">               log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>主要方法就是 processSocket </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Process the given SocketWrapper with the given status. Used to trigger</span></span><br><span class="line"><span class="comment">   * processing as if the Poller (for those endpoints that have one)</span></span><br><span class="line"><span class="comment">   * selected the socket.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> socketWrapper The socket wrapper to process</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> event         The socket event to be processed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dispatch      Should the processing be performed on a new</span></span><br><span class="line"><span class="comment">   *                          container thread</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> if processing was triggered successfully</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">          SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">          <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">              sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sc.reset(socketWrapper, event);</span><br><span class="line">          &#125;</span><br><span class="line">          Executor executor = getExecutor();</span><br><span class="line">          <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">              executor.execute(sc);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sc.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">          getLog().warn(sm.getString(<span class="string">&quot;endpoint.executor.fail&quot;</span>, socketWrapper) , ree);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(t);</span><br><span class="line">          <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">          <span class="comment">// the pool and its queue are full</span></span><br><span class="line">          getLog().error(sm.getString(<span class="string">&quot;endpoint.process.fail&quot;</span>), t);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用 SocketProcessorBase 的 run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (socketWrapper) &#123;</span><br><span class="line">           <span class="comment">// It is possible that processing may be triggered for read and</span></span><br><span class="line">           <span class="comment">// write at the same time. The sync above makes sure that processing</span></span><br><span class="line">           <span class="comment">// does not occur in parallel. The test below ensures that if the</span></span><br><span class="line">           <span class="comment">// first event to be processed results in the socket being closed,</span></span><br><span class="line">           <span class="comment">// the subsequent events are not processed.</span></span><br><span class="line">           <span class="keyword">if</span> (socketWrapper.isClosed()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           doRun();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

   <img src="/2021/05/28/tomcat8-5%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%89%E4%B9%8BEndpoint/1.jpg" class title="tomcat">

<p>我们查看 NioEndpoint  这个类的 doRun方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         NioChannel socket = socketWrapper.getSocket();</span><br><span class="line">         SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> handshake = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          ....</span><br><span class="line">             <span class="keyword">if</span> (handshake == <span class="number">0</span>) &#123;</span><br><span class="line">                 SocketState state = SocketState.OPEN;</span><br><span class="line">                 <span class="comment">// Process the request from this socket</span></span><br><span class="line">                 <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     state = getHandler().process(socketWrapper, event);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;</span><br><span class="line">                     close(socket, key);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == -<span class="number">1</span> ) &#123;</span><br><span class="line">                 close(socket, key);</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_READ)&#123;</span><br><span class="line">                 socketWrapper.registerReadInterest();</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_WRITE)&#123;</span><br><span class="line">                 socketWrapper.registerWriteInterest();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (CancelledKeyException cx) &#123;</span><br><span class="line">             socket.getPoller().cancelledKey(key);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (VirtualMachineError vme) &#123;</span><br><span class="line">             ExceptionUtils.handleThrowable(vme);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             log.error(<span class="string">&quot;&quot;</span>, t);</span><br><span class="line">             socket.getPoller().cancelledKey(key);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             socketWrapper = <span class="keyword">null</span>;</span><br><span class="line">             event = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//return to cache</span></span><br><span class="line">             <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                 processorCache.push(<span class="keyword">this</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里省略了部分代码 看到代码就我们就可以很确定核心代码就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process the request from this socket</span></span><br><span class="line">                  <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      state = getHandler().process(socketWrapper, event);</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>

<p>进入process方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       SocketState state = SocketState.CLOSED;</span><br><span class="line">       Iterator&lt;DispatchType&gt; dispatches = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (dispatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">               DispatchType nextDispatch = dispatches.next();</span><br><span class="line">               state = dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;</span><br><span class="line">               <span class="comment">// Do nothing here, just wait for it to get recycled</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;</span><br><span class="line">               state = dispatch(status);</span><br><span class="line">               <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">                   <span class="comment">// There may be pipe-lined data to read. If the data isn&#x27;t</span></span><br><span class="line">                   <span class="comment">// processed now, execution will exit this loop and call</span></span><br><span class="line">                   <span class="comment">// release() which will recycle the processor (and input</span></span><br><span class="line">                   <span class="comment">// buffer) deleting any pipe-lined data. To avoid this,</span></span><br><span class="line">                   <span class="comment">// process it now.</span></span><br><span class="line">                   state = service(socketWrapper);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">               <span class="comment">// Extra write event likely after async, ignore</span></span><br><span class="line">               state = SocketState.LONG;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_READ)&#123;</span><br><span class="line">               state = service(socketWrapper);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Default to closing the socket if the SocketEvent passed in</span></span><br><span class="line">               <span class="comment">// is not consistent with the current state of the Processor</span></span><br><span class="line">               state = SocketState.CLOSED;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">               getLog().debug(<span class="string">&quot;Socket: [&quot;</span> + socketWrapper +</span><br><span class="line">                       <span class="string">&quot;], Status in: [&quot;</span> + status +</span><br><span class="line">                       <span class="string">&quot;], State out: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (state != SocketState.CLOSED &amp;&amp; isAsync()) &#123;</span><br><span class="line">               state = asyncPostProcess();</span><br><span class="line">               <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                   getLog().debug(<span class="string">&quot;Socket: [&quot;</span> + socketWrapper +</span><br><span class="line">                           <span class="string">&quot;], State after async post processing: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (dispatches == <span class="keyword">null</span> || !dispatches.hasNext()) &#123;</span><br><span class="line">               <span class="comment">// Only returns non-null iterator if there are</span></span><br><span class="line">               <span class="comment">// dispatches to process.</span></span><br><span class="line">               dispatches = getIteratorAndClearDispatches();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END ||</span><br><span class="line">               dispatches != <span class="keyword">null</span> &amp;&amp; state != SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> 这里面 有dispatch、service、asyncPostProcess这几个核心方法调用，最终跟踪到最后其实都会看到如下样板代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">....  </span><br><span class="line">    <span class="comment">// Process the request in the adapter</span></span><br><span class="line">            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                    getAdapter().service(request, response);</span><br><span class="line">                    <span class="comment">// Handle when the response was committed before a serious</span></span><br><span class="line">                    <span class="comment">// error occurred.  Throwing a ServletException should both</span></span><br><span class="line">                    <span class="comment">// set the status to 500 and set the errorException.</span></span><br><span class="line">                    <span class="comment">// If we fail here, then the response is likely already</span></span><br><span class="line">                    <span class="comment">// committed, so we can&#x27;t try and set headers.</span></span><br><span class="line">                    <span class="keyword">if</span>(keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">                            statusDropsConnection(response.getStatus())) &#123;</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_CLEAN, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (HeadersTooLargeException e) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">&quot;http11processor.request.process&quot;</span>), e);</span><br><span class="line">                    <span class="comment">// The response should not have been committed but check it</span></span><br><span class="line">                    <span class="comment">// anyway to be safe</span></span><br><span class="line">                    <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.reset();</span><br><span class="line">                        response.setStatus(<span class="number">500</span>);</span><br><span class="line">                        setErrorState(ErrorState.CLOSE_CLEAN, e);</span><br><span class="line">                        response.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>); <span class="comment">// <span class="doctag">TODO:</span> Remove</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ...</span><br></pre></td></tr></table></figure>

<p>以上代码是<strong>org.apache.coyote.http11.Http11Processor</strong> <strong>service（）</strong>方法的部分内容</p>
<p>主要查看 getAdapter().service(request, response);这段内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// Parse and set Catalina and configuration specific</span></span><br><span class="line">          <span class="comment">// request parameters</span></span><br><span class="line">          postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">          <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">              <span class="comment">//check valves if we support async</span></span><br><span class="line">              request.setAsyncSupported(</span><br><span class="line">                      connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">              <span class="comment">// Calling the container</span></span><br><span class="line">              <span class="comment">//这个是这段方法的核心代码</span></span><br><span class="line">              connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                      request, response);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">              async = <span class="keyword">true</span>;</span><br><span class="line">              ReadListener readListener = req.getReadListener();</span><br><span class="line">              <span class="keyword">if</span> (readListener != <span class="keyword">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">                  <span class="comment">// Possible the all data may have been read during service()</span></span><br><span class="line">                  <span class="comment">// method so this needs to be checked here</span></span><br><span class="line">                  ClassLoader oldCL = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      oldCL = request.getContext().bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">                          req.getReadListener().onAllDataRead();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      request.getContext().unbind(<span class="keyword">false</span>, oldCL);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              Throwable throwable =</span><br><span class="line">                      (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// If an async request was started, is not going to end once</span></span><br><span class="line">              <span class="comment">// this container thread finishes and an error occurred, trigger</span></span><br><span class="line">              <span class="comment">// the async error process</span></span><br><span class="line">              <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  request.getAsyncContextInternal().setErrorState(throwable, <span class="keyword">true</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              request.finishRequest();</span><br><span class="line">              response.finishResponse();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          AtomicBoolean error = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">          res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">              <span class="comment">// Connection will be forcibly closed which will prevent</span></span><br><span class="line">              <span class="comment">// completion happening at the usual point. Need to trigger</span></span><br><span class="line">              <span class="comment">// call to onComplete() here.</span></span><br><span class="line">              res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="keyword">null</span>);</span><br><span class="line">              async = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Access log</span></span><br><span class="line">          <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">              <span class="comment">// Log only if processing was invoked.</span></span><br><span class="line">              <span class="comment">// If postParseRequest() failed, it has already logged it.</span></span><br><span class="line">              Context context = request.getContext();</span><br><span class="line">              <span class="comment">// If the context is null, it is likely that the endpoint was</span></span><br><span class="line">              <span class="comment">// shutdown, this connection closed and the request recycled in</span></span><br><span class="line">              <span class="comment">// a different thread. That thread will have updated the access</span></span><br><span class="line">              <span class="comment">// log so it is OK not to update the access log here in that</span></span><br><span class="line">              <span class="comment">// case.</span></span><br><span class="line">              <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  context.logAccess(request, response,</span><br><span class="line">                          System.currentTimeMillis() - req.getStartTime(), <span class="keyword">false</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          req.getRequestProcessor().setWorkerThreadName(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Recycle the wrapper request and response</span></span><br><span class="line">          <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">              request.recycle();</span><br><span class="line">              response.recycle();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>   connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</p>
<p>这句代码就是获取在pipeline管道的的第一个Value的实现 ，在tomcat中 Value实现比较多</p>
 <img src="/2021/05/28/tomcat8-5%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%89%E4%B9%8BEndpoint/2.jpg" class title="tomcat">

<p>这里有26个 这里的Value有点像Servlet里面的Filter 一样 我们直接看<strong>org.apache.catalina.core.StandardWrapperValve</strong>  在tomcat中servlet都被包装成里 Wrapper</p>
<p>在 invoke方法里面 比较长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the servlet we are managing, respecting the rules regarding</span></span><br><span class="line"><span class="comment"> * servlet lifecycle and SingleThreadModel support.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request Request to be processed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response Response to be produced</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IOException if an input/output error occurred</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> ServletException if a servlet error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize local variables we may need</span></span><br><span class="line">    <span class="keyword">boolean</span> unavailable = <span class="keyword">false</span>;</span><br><span class="line">    Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// This should be a Request attribute...</span></span><br><span class="line">    <span class="keyword">long</span> t1=System.currentTimeMillis();</span><br><span class="line">    requestCount.incrementAndGet();</span><br><span class="line">    StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    Context context = (Context) wrapper.getParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for the application being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardContext.isUnavailable&quot;</span>));</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for the servlet being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">        container.getLogger().info(sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                wrapper.getName()));</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                    sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                    sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(</span><br><span class="line">                sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                        wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), StandardWrapper.getRootCause(e));</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    DispatcherType dispatcherType = DispatcherType.REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">            requestPathMB);</span><br><span class="line">    <span class="comment">// Create the filter chain for this request</span></span><br><span class="line">    ApplicationFilterChain filterChain =</span><br><span class="line">            ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet&#x27;s service() method</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// Swallow output if needed</span></span><br><span class="line">            <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SystemLogHandler.startCapture();</span><br><span class="line">                    <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                        request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                response.getResponse());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    String log = SystemLogHandler.stopCapture();</span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        context.getLogger().info(log);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                    request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterChain.doFilter</span><br><span class="line">                        (request.getRequest(), response.getResponse());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientAbortException | CloseNowException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">            container.getLogger().debug(sm.getString(</span><br><span class="line">                    <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                    context.getName()), e);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们可以看到 tomcat 是如何把wrapper转成 Servlet的已经处理Servlet3 提供的异步处理请求的实现，</p>
<p>在这里的核心方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChain.doFilter(request.getRequest(),response.getResponse());</span><br></pre></td></tr></table></figure>

<p>在 **org.apache.catalina.core.ApplicationFilterChain ** <strong>doFilter</strong>方法有一个内部 方法 <strong>internalDoFilter</strong></p>
<p>这个方法的代码如下 前半部分是处理flter的后半部分是调用Servlet.Service方法的 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ServletResponse response)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Call the next filter if there is one</span></span><br><span class="line">       <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">           ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Filter filter = filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(</span><br><span class="line">                       filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">                   request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                   <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">                   <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">                   Principal principal =</span><br><span class="line">                       ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">                   Object[] args = <span class="keyword">new</span> Object[]&#123;req, res, <span class="keyword">this</span>&#125;;</span><br><span class="line">                   SecurityUtil.doAsPrivilege (<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">               ExceptionUtils.handleThrowable(e);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;filterChain.filter&quot;</span>), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We fell off the end of the chain -- call the servlet instance</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">               lastServicedRequest.set(request);</span><br><span class="line">               lastServicedResponse.set(response);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">               request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,</span><br><span class="line">                       Boolean.FALSE);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Use potentially wrapped request from this point</span></span><br><span class="line">           <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">                   (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;</span><br><span class="line">                   Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">               <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">               <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">               Principal principal =</span><br><span class="line">                   ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">               Object[] args = <span class="keyword">new</span> Object[]&#123;req, res&#125;;</span><br><span class="line">               SecurityUtil.doAsPrivilege(<span class="string">&quot;service&quot;</span>,</span><br><span class="line">                                          servlet,</span><br><span class="line">                                          classTypeUsedInService,</span><br><span class="line">                                          args,</span><br><span class="line">                                          principal);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               servlet.service(request, response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">           ExceptionUtils.handleThrowable(e);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;filterChain.servlet&quot;</span>), e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">               lastServicedRequest.set(<span class="keyword">null</span>);</span><br><span class="line">               lastServicedResponse.set(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p> 至此 Servlet的 service方法就传入到了我们ServletRequesst,ServletResponse</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/06/01/tomcat8-5%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%9B%9B%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">tomcat8.5源码学习四之类加载机制</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/05/19/%E8%AE%B0%E5%BD%95apache-commons-exec%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">记录apache-commons-exec使用错误</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Healthy Mind</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>



<script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script>




    <script src="/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script>
    
</div>



</body>
</html>
